package com.example.robotic_events_test;

import android.util.Log;
import com.google.android.gms.tasks.Task;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.QuerySnapshot;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 * Handles CRUD operations for event documents in Firebase Firestore.
 * <p>
 * The {@code EventModel} class provides methods to create, read, update, and delete
 * event records stored in a Firestore collection. It abstracts Firestore logic from
 * the rest of the app and ensures consistent data structure for all events.
 * </p>
 *
 * <p>Each event document contains the following fields:</p>
 * <ul>
 *   <li>{@code id} — unique identifier for the event</li>
 *   <li>{@code title} — name of the event</li>
 *   <li>{@code description} — detailed event information</li>
 *   <li>{@code dateTime} — timestamp (in milliseconds) for the event time</li>
 *   <li>{@code location} — event venue or location</li>
 *   <li>{@code category} — event category (e.g., tech, robotics, workshop)</li>
 *   <li>{@code organizerId} — ID of the user or organization hosting the event</li>
 *   <li>{@code totalCapacity} — maximum number of participants</li>
 *   <li>{@code price} — entry fee (if applicable)</li>
 *   <li>{@code status} — "open" by default, can change to "closed" or "cancelled"</li>
 *   <li>{@code imageUrl} — URL of the event’s image/banner</li>
 *   <li>{@code waitlist} — list of users currently on the waitlist</li>
 * </ul>
 */
public class EventModel {

    /** Instance of Firestore database. */
    private final FirebaseFirestore db;

    /** Name of the Firestore collection used for events. */
    private final String collectionName;

    /** Reference to the Firestore collection for events. */
    private final CollectionReference eventsCollection;

    /**
     * Creates a new EventModel for the specified collection.
     *
     * @param collectionName the name of the Firestore collection (e.g., "events" or "events_mock")
     */
    EventModel(String collectionName) {
        this.collectionName = collectionName;
        this.db = FirebaseFirestore.getInstance();
        this.eventsCollection = db.collection(collectionName);
    }

    /**
     * Creates a new EventModel that uses the default {@code "events"} collection.
     */
    EventModel() {
        this("events");
    }

    /**
     * Saves a new event document to Firestore.
     * <p>
     * If an {@code id} is provided, the event is stored under that document ID and
     * overwrites existing data. Otherwise, a new document is created and assigned
     * an auto-generated ID.
     * </p>
     *
     * @param id             Optional document ID. Leave null to auto-generate.
     * @param title          Title of the event.
     * @param description    Description of the event.
     * @param dateTime       Time of the event in milliseconds since epoch.
     * @param location       Location where the event will occur.
     * @param totalCapacity  Maximum number of attendees allowed.
     * @param price          Ticket or entry fee for the event.
     * @param organizerId    Organizer's user ID.
     * @param category       Category label for the event (e.g., robotics, AI, competition).
     * @param imageUrl       URL for the event’s banner image.
     */
    public void saveEvent(
            String id,
            String title,
            String description,
            long dateTime,
            String location,
            int totalCapacity,
            double price,
            String organizerId,
            String category,
            String imageUrl
    ) {
        Map<String, Object> eventData = new HashMap<>();
        eventData.put("title", title);
        eventData.put("description", description);
        eventData.put("dateTime", dateTime);
        eventData.put("location", location);
        eventData.put("category", category);
        eventData.put("organizerId", organizerId);
        eventData.put("totalCapacity", totalCapacity);
        eventData.put("status", "open");
        eventData.put("price", price);
        eventData.put("imageUrl", imageUrl);
        eventData.put("waitlist", new ArrayList<>());

        if (id != null && !id.isEmpty()) {
            // Store under a specific document ID (overwrites existing data)
            eventData.put("id", id);
            eventsCollection.document(id)
                    .set(event)
                    .addOnSuccessListener(aVoid ->
                            Log.d("EventModel", "Event saved with ID " + id))
                    .addOnFailureListener(e ->
                            Log.e("EventModel", "Error saving event", e));
        } else {
            // Create a new document with an autogenerated ID
            eventsCollection.add(eventData)
                    .addOnSuccessListener(documentRef -> {
                        String generatedId = documentRef.getId();
                        documentRef.update("id", generatedId);
                        Log.d("EventModel", "Event added with autogenerated ID " + generatedId);
                    })
                    .addOnFailureListener(e ->
                            Log.e("EventModel", "Error adding event", e));
        }
    }

    /**
     * Retrieves a single event by its document ID.
     *
     * @param id the document ID of the event
     * @return a {@link Task} containing the event’s {@link DocumentSnapshot}
     */
    public Task<DocumentSnapshot> getEvent(String id) {
        return eventsCollection.document(id).get();
    }

    /**
     * Retrieves all events from the collection.
     *
     * @return a {@link Task} containing a {@link QuerySnapshot} of all event documents
     */
    public Task<QuerySnapshot> getAllEvents() {
        return eventsCollection.get();
    }

    /**
     * Updates an existing event with new data.
     *
     * @param id   the document ID of the event to update
     * @param data a map of field names and updated values
     * @return a {@link Task} that completes when the update is finished
     * @throws IllegalArgumentException if {@code id} is null or empty
     */
    public Task<Void> updateEvent(String id, Map<String, Object> data) {
        if (id == null || id.isEmpty()) {
            throw new IllegalArgumentException("Document ID cannot be null or empty");
        }
        return eventsCollection.document(id).update(data);
    }

    /**
     * Deletes an event from Firestore.
     *
     * @param id the document ID of the event to delete
     * @return a {@link Task} that completes when the deletion is finished
     * @throws IllegalArgumentException if {@code id} is null or empty
     */
    public Task<Void> deleteEvent(String id) {
        if (id == null || id.isEmpty()) {
            throw new IllegalArgumentException("Document ID cannot be null or empty");
        }
        return eventsCollection.document(id).delete();
    }
}
